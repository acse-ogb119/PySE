# -*- coding: utf-8 -*-
#
# (c) Copyright 2003, 2004, 2005
#     Author: Åsmund Ødegård
#     Simula Research Laboratory AS
#     
#     This file is part of PyFDM.
#
#     PyFDM is free software; you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation; either version 2 of the License, or
#     (at your option) any later version.
#
#     PyFDM is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with PyFDM; if not, write to the Free Software
#     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#
# Utils; A collection of utilities.
#

UtilsError = "Error in Utils"

pyFDMconf = {}

import sys,os
if os.environ.get('NUMPYARRAY','') == 'Numeric': 
    raise UtilsError, "You can not use only Numeric with this framework, as some operations do require numarray"
    #import Numeric as _n
elif sys.modules.has_key('Numeric'):
    # try to import numarray as _n
    try:
        import numarray as _n
    except:
        raise UtilsError, "You can not use only Numeric with this framework, as some operations do require numarray"
else:
    import numarray as _n

import operator as _O
import math

# make copy and deepcopy available, as these are useful
from copy import copy,deepcopy


# Try to load parallel environment. The default is to load pypar.
parallelLoaded = None
# if pypar unavail.
class pyparfuncs(object):
    def size(s):
        return 0
    def rank(s):
        return 0

try:
    if not os.environ.get('NOTLOADPYPAR',''):
        import pypar
        parallelLoaded = True
        pyFDMconf['parallelLoaded'] = True
        pyFDMconf['parallel_rank']  = pypar.rank()
        pyFDMconf['parallel_size']  = pypar.size()
    else:
        pypar = pyparfuncs()
        pyFDMconf['parallelLoaded'] = False
        pyFDMconf['parallel_rank']  = pypar.rank()
        pyFDMconf['parallel_size']  = pypar.size()

except:
    parallelLoaded = False
    pyFDMconf['parallelLoaded'] = False
    pyFDMconf['parallel_rank']  = 0
    pypar = pyparfuncs()

# generator for constant function-objects (easy way of making closures).
# We might also do this with closures (maybe new consept in python 2.2/2.3):
# def make_constfu(value):
#    def constfu(*args): return value
#    return constfu
#
# For now, we leave the original construction with class.
class constfunc:
   def __init__(self,value):
      self.val = value

   def __call__(self, *args):
      return self.val

def addtuples(self,tn,tm):
   ti = []
   #assume equal lengths:
   for i in range(len(tn)):
      ti.append(tn[i] + tm[i])
   return ti


# Iterator over tuples. Works for general ranges of the type 
# (i,j,k,...) -  (I,J,K,...)
#
class tupleIterator(object):

    def __init__(self,no_inds,start,stop):
        self.no_inds = no_inds
        self.start = list(start)
        self.stop = list(stop)

        if len(start) != no_inds or len(stop) != no_inds:
            raise UtilsError, "length of start and stop tuple must match no_inds"
         
        # Set nextitem = start, and decrement to be ready for first iteration:
        # this must be copy:
        self.nextitem = list(start)
        self.nextitem[0] -= 1

    def __iter__(self):
        return self

    def reset(self):
        self.nextitem = list(self.start)
        self.nextitem[0] -= 1

    def getBounds(self):
        """Get bounds for this tupleiterator.
           Parameters: 
            none
           Returns:
            a tuple with two tuples, start and stop index.
        """
        return (self.start,self.stop)

    def setNewBounds(self,bounds,iOB=False):
        """Set new bounds for the iterator. Restrict to old bounds if iOB=True
           
           Parameters:
             bounds: A tuple or list of tuples setting the extreme min and max
                     bounds for the iterator, just like start and stop in the 
                     constructor. len of start and stop should match, and if 
                     different from the old no_inds, a new number of space dimensions
                     must be set.
             iOB: a True/False flag, short for intersectOldBoundaries. The meaning 
                  is that if this flag is True, we restrict the tuples actually 
                  generated by the iterator to the intersection between the old and
                  new boundaries, such that no tuple generated by the new iterator 
                  is outside the set of tuples generated by the old bounds.
        """
        
        # check that len of bounds is 2:
        if len(bounds) != 2:
            raise UtilsError, "both start and stop must be specified in the bounds for setNewBounds"
        if len(bounds[0]) != len(bounds[1]):
            raise UtilsError, "number of dimensions in start and stop does not match in setNewBounds"

        if not iOB:
            self.start = tuple(bounds[0])
            self.stop = tuple(bounds[1])

            # instead of checking len, and then eventually update, we just 
            # reset the no_inds
            self.no_inds = len(bounds[0])

            self.reset()
        else:
            # make sure that the new bounds are contained in the old
            if len(bounds[0]) != self.no_inds:
                raise UtilsError,"intersectOldBoundaries set True, but dimensions disagree"
            newstart = []
            newstop = []
            for i in xrange(self.no_inds):
                # TODO: Remove debug print
                #print "    bounds, start, stop: ",bounds[0][i],self.start[i],self.stop[i],bounds[1][i]
                if bounds[0][i] >= self.start[i] and bounds[0][i] <= self.stop[i]:
                    newstart.append(bounds[0][i])
                elif bounds[0][i] < self.start[i]:
                    newstart.append(self.start[i])
                else:
                    newstart.append(self.stop[i])
                if bounds[1][i] <= self.stop[i] and bounds[1][i] >= self.start[i]:
                    newstop.append(bounds[1][i])
                elif bounds[1][i] > self.stop[i]:
                    newstop.append(self.stop[i])
                else:
                    newstop.append(self.start[i])

            self.start = tuple(newstart)
            self.stop = tuple(newstop)

            #TODO: Remove debug print
            #print "   setNewBounds: ",self.start,self.stop
            self.reset()
        
    def next(self):
        i=0
        while i < self.no_inds:
            # All but last index
            if i < self.no_inds-1:
                if self.nextitem[i] < self.stop[i]:
                    self.nextitem[i] += 1
                    break
                else:
                    self.nextitem[i] = self.start[i]
                    i += 1
            # Special treatment for the last index
            else:
                if self.nextitem[i] < self.stop[i]:
                    self.nextitem[i] += 1
                    break
                else:
                    raise StopIteration
        return tuple(self.nextitem)

class boundaryTupleIterator(object):
    # This one uses the edgeGenerator, wrapped in an iterator to have the reset.
    def __init__(self,no_inds,start,stop):
        self.no_inds = no_inds
        self.start = start
        self.stop = stop
        # start with None as controlList for edgeGenerator
        self.controllist = None
        self.boundaryGen = edgeGenerator(no_inds,start,stop,self.controllist)
        self.used = False

    def __iter__(self):
        self.used = True
        return self

    def reset(self):
        # simply create a new edgeGenerator:
        # use the current active controlList
        if self.used:
            self.boundaryGen = edgeGenerator(self.no_inds,self.start,self.stop,self.controllist)
            self.used = False

      
    def getBounds(self):
        """Get bounds for this tupleIterator
           Parameters: 
            none
           Returns:
            a tuple with two tuples, start and stop index.
        """
        return (self.start,self.stop)

    def setNewBounds(self, bounds, iOB=False):
        """Set new bounds for the iterator. Restrict to old bounds if iOB=True
           
           Parameters:
             bounds: A tuple or list of tuples setting the extreme min and max
                     bounds for the iterator, just like start and stop in the 
                     constructor. len of start and stop should match, and if 
                     different from the old no_inds, a new number of space dimensions
                     must be set.
             iOB: a True/False flag, short for intersectOldBoundaries. The meaning 
                  is that if this flag is True, we restrict the tuples actually 
                  generated by the iterator to the intersection between the old and
                  new boundaries, such that no tuple generated by the new iterator 
                  is outside the set of tuples generated by the old bounds.
        """
        # not sure how to handle iOB=True in this case. The problem is that (think 
        # grid) some entries generated may be on "interior" boundaries which 
        # we do not want to include. I can think of at least two approaches:
        #
        #  1. walk thorugh the iterator, assemble all entries in a list, but remove 
        #     those entries which fall outside the new bounds.
        #  2. modify edgeGenerator to handle this automatically - i.e additional 
        #     arguments to edgeGenerator are used to make sure that only some of the
        #     edges are included (i.e., those that are known to be on "physical" 
        #     boundaries if you think partitioned grid. 

        #print "bTI: setNewBounds, ",bounds,", iOB = ",iOB

        if not iOB:
            # let's start with the simple case :)
            if len(bounds) != 2 or len(bounds[0]) != len(bounds[1]):
                raise UtilsError, "dimensions in new bounds have to agree"
            self.no_inds = len(bounds[0])
            self.start = bounds[0]
            self.stop = bounds[1]
            self.boundaryGen = edgeGenerator(self.no_inds,self.start,self.stop,None)
        else:
            #
            # TODO: there is a bug here!
            # The new bounds should be restricted to the old bounds first,
            # that is: if bounds[0][i] < self.start[i]: bounds[0][i] = self.start[i]
            # etc.  ( > for stop).
            #
            # This is not a problem for parallelization. 
            # It is annoying from user-space, but can be dealt with manually.
            # Fix in due time!
            #
            # If flag is True, new bounds include some of the old
            # boundary. If flag is False, we can just use a nullGenerator
            # Start with a false flag:
            flag = False
            # semantics for controlList:
            # len(controlList) == self.no_inds
            # controlList[i] = 0: no boundary in dir. i
            # controlList[i] = 1: left side of dir. i is boundary
            # controlList[i] = 2: right side of dir. i is boundary
            # controlList[i] = 3: both sides of dir. i is boundary
            controlList = list(getZeroTuple(self.start))
            for i in xrange(self.no_inds):
                if bounds[0][i] == self.start[i]:
                    flag = True
                    controlList[i] += 1
                if bounds[1][i] == self.stop[i]:
                    flag = True
                    controlList[i] += 2
            if flag:
                # create a edgeGenerator with additional requirements
                self.start = bounds[0]
                self.stop = bounds[1]
                # TODO: Remove debug pritn
                #print "bounds, control ",self.start,", ",self.stop,", ",self.controllist,", ",id(self.controllist)
                # store the new controllist such that reset can use this one:
                self.controllist = controlList
                self.boundaryGen = edgeGenerator(self.no_inds,self.start,self.stop,self.controllist)
            else:
                self.start = bounds[0]
                self.stop = bounds[1]
                self.boundaryGen = nullGenerator()


    def next(self):
        return self.boundaryGen.next()


#
#Nice try, but not completely right...
#def oldwrongedgeGenerator(n,start,stop):
#   # Fix from 1 to n positions in outer-positions, create a cornerTupleIterator
#   # for these. Then create a innerIterator for the rest (front and tail)
#
#   #print "edgeGen: n: %d, start: %s, stop: %s" % ( n,start,stop)
#   for i in xrange(n):
#      #print "i is %d" % (i)
#      for j in xrange(n-i):
#         #print "j is %d" % (j)
#         # Create a fixed-indices iterator
#         startfix=start[i:i+j+1]
#         stopfix=stop[i:i+j+1]
#
#         #print "j+1: %d, startfix: %s, stopfix: %s" % ( j+1,startfix,stopfix )
#         fixiterator=cornerTupleIterator(j+1,startfix,stopfix)
#
#         if j+1 < n:
#            # Create a unfixed-indices iterator
#            frontstart = start[:i]
#            frontstop  = stop[:i]
#            tailstart  = start[i+j+1:]
#            tailstop   = stop[i+j+1:]
#            startunfix = frontstart + tailstart
#            stopunfix  = frontstop + tailstop
#
#            #print "n-j-1: %d, startunfix: %s, stopunfix: %s" % ( n-j-1,startunfix,stopunfix)
#            unfixiterator = innerTupleIterator(n-j-1,startunfix,stopunfix)
#
#         # if not all is fixed:
#         if j+1 < n:
#            for fix in fixiterator:
#               unfixiterator.reset()
#               for unfix in unfixiterator:
#                  # split unfix in front and tail:
#                  # remember that the fixed part is not there
#                  frontunfix=unfix[:i]
#                  tailunfix=unfix[i:]
#                  # create the full version:
#                  fulledge = frontunfix + fix + tailunfix
#                  # yield the value: That is, store state to pick up later, and
#                  # return the fulledge value:
#                  yield fulledge
#         else:
#            for fix in fixiterator:
#               fulledge = fix
#               # yield the value: That is, store state to pick up later, and
#               # return the fulledge value:
#               yield fulledge
#
 
def edgeIteratorGenerator(n,start,stop):
   """edgeIteratorGenerator: generate tuple-iterator for all edges. The iterators
      are returned such that they may be used in different settings. This is a
      key component in the edgeGenerator.
      arguments: n the highest edge-order, that is the max number of indices to
                   fix.
                 start: consider a box-geometry, this is the origin
                 stop:  consider a box-geometry, this is the max-index in all
                        directions.
      yields:    a tuple with three entries, the first is the edgeIterator, the
                 second is the current base showing which indices are fixed.
                 The third entry is the fixedpart, corresponds to the number of
                 ones in the base, to find out whether some index is fixed at
                 minimum or maximum.
   """
   #Some basic information:
   tuplen = len(start)
   if tuplen != len(stop):
      raise UtilsError, "length of start and stop does not match"

   #If start[i] == stop[i] for some i, and n=len(start), reduce n, else
   #assume that the user do the right thing.
   degenerated_directions = {}
   if ( n == len(start) ):
      for i in xrange(len(start)):
         if ( start[i] == stop[i] ):
            n = n-1
            degenerated_directions[i] = True

   #print "These directions are degenerated: ",degenerated_directions

   #remark no more than n indices can be fixed. 
   baseiterator = cornerTupleIteratorNoDuplicates(tuplen,getZeroTuple(start),getOnesTuple(start))
   validbase = []
   degeneratedAdded = False
   for tu in baseiterator:
      # count the number of ones to validate:
      # If the 1 is in a degenerate direction, no other 1's are allowed!
      numones = 0
      degeneratedFlag = False
      for i in xrange(len(tu)): 
         if tu[i] > 0:
            numones += 1
            # Use has_key here, but 'i in degenerated_directions' may be more 
            # presice syntax.
            if degenerated_directions.has_key(i):
                # Will only allow this if numones stay at 1!
                # and no other degenerated direction already is added.
                degeneratedFlag = True
      if numones > 0 and numones <= n and not degeneratedFlag:
         validbase.append(tu)
      elif numones == 1 and degeneratedFlag and not degeneratedAdded:
         validbase.append(tu)
         degeneratedAdded = True

   #print "Valid bases: ",validbase

   # Now, for each valid base, create a suitable edgePartIt, then for each
   # entry in this iterator, put together with the innerpart and create
   # a full tuplerIterator. yield.

   for basetu in validbase:
      # create the fixed part:
      startedge=[]
      stopedge=[]
      for i in xrange(tuplen):
         if basetu[i] == 1:
            startedge.append(start[i])
            stopedge.append(stop[i])

      #create the edgeTupleIterator Part:
      edgepart = cornerTupleIteratorNoDuplicates(len(startedge),startedge,stopedge)

      for edgetu in edgepart:
         # Fill in a full template, adjust the rest for inner.
         fullstart = []
         fullstop = []
         edgeind=0
         for i in xrange(tuplen):
            if basetu[i] == 1:
               # Fix this index
               fullstart.append(edgetu[edgeind])
               fullstop.append(edgetu[edgeind])
               edgeind +=1
            else:
               # This index is inner (if not degenerate):
               if ( start[i] == stop[i] ):
                  fullstart.append(start[i])
                  fullstop.append(stop[i])
               else:
                  fullstart.append(start[i]+1)
                  fullstop.append(stop[i]-1)
         fulledgeiterator = tupleIterator(tuplen,fullstart,fullstop)
         yield (fulledgeiterator,basetu,edgetu)

def edgeGenerator(n,start,stop,controlList=None,yieldAllInfo=False):
    """edgeGenerator: generates all edge-indices in for the range start-stop,
       assumed that this is a box-geometry. Edges up to order n is returned.
       This mean that from 1 to n indices are always fixed. n = start.len() =>
       all boundary-nodes.
    """
    
    #print "Create new edgeGenerator for ",n,",",start,",",stop,",",controlList,", ",yieldAllInfo

    if not controlList:
        edge = edgeIteratorGenerator(n,start,stop)
        for edgetuples in edge:
            if yieldAllInfo:
                yield edgetuples
            else:
                for tuple in edgetuples[0]:
                    yield tuple
    else:
        # TODO: Remove debug print
        #print "There is a controlList, ",controlList
        # for each part obtained from the edgeIteratorGenerator, we have to 
        # check against the controlList to see whether it should be used or not.
        edge = edgeIteratorGenerator(n,start,stop)
        for edgetuples in edge:
            # TODO: Remove debug print
            #print "current base, edge: ",edgetuples[1],edgetuples[2]
            # Have to decide whether we should include this or not:
            # a non-zero controlvalue make it a candidate
            # Still, we have to check whether we are at the right end.
            controlvalue = tupleInnerProd(controlList,edgetuples[1])
            if controlvalue:
                # find the direction(s) where both base is 1 and controlList 
                # is non-zero
                edgeIndex = -1
                flag = False
                for i in xrange(n):
                    if edgetuples[1][i] > 0:
                        edgeIndex += 1 # current location in edgetuples[2] to check
                        # then check the controlList, and if necessary the edge-part
                        if controlList[i] == 3:
                            # nothing to check, we have a vlid one
                            flag = True
                        elif controlList[i] == 1:
                            # have to check the edge-part:
                            if edgetuples[2][edgeIndex] == start[i]:
                                # we are at the right edge
                                flag = True
                        elif controlList[i] == 2:
                            if edgetuples[2][edgeIndex] == stop[i]:
                                flag = True
                if flag:
                    if yieldAllInfo:
                        yield edgetuples
                    else:
                        for tuple in edgetuples[0]:
                            yield tuple
               
               
class innerTupleIterator(object):
    def __init__(self,no_inds,start,stop):
        self.start=incrTuple(start)
        self.stop=decrTuple(stop)
        self.no_inds = no_inds

        self.it = tupleIterator(self.no_inds,self.start,self.stop)

    def __iter__(self):
        return self

    def next(self):
        return self.it.next()

    def reset(self):
        self.it.reset()

    def getBounds(self):
        """Get bounds for this tupleIterator
           Parameters: 
            none
           Returns:
            a tuple with two tuples, start and stop index.
        """
        return (self.start,self.stop)

    def setNewBounds(self,bounds,iOB=False):
        """Set new bounds for the iterator. Restrict to old bounds if iOB=True
           
           Parameters:
             bounds: A tuple or list of tuples setting the extreme min and max
                     bounds for the iterator, just like start and stop in the 
                     constructor. len of start and stop should match, and if 
                     different from the old no_inds, a new number of space dimensions
                     must be set.
             iOB: a True/False flag, short for intersectOldBoundaries. The meaning 
                  is that if this flag is True, we restrict the tuples actually 
                  generated by the iterator to the intersection between the old and
                  new boundaries, such that no tuple generated by the new iterator 
                  is outside the set of tuples generated by the old bounds.
        """
        
        # If iOB is True, we assume that the new bounds should be inside the old, 
        # without incr/decr. 
        # If iOB is False, we just set as before and incr/decr
        if iOB:
            # make sure that dimensions agree:
            newstart = []
            newstop = []
            if len(bounds[0]) != self.no_inds:
                raise UtilsError, "intersectOldBounds is true, but dimensions disagree"
            for i in xrange(self.no_inds):
                if self.start[i] > bounds[0][i]:
                    newstart.append(self.start[i])
                else:
                    newstart.append(bounds[0][i])
                if self.stop[i] < bounds[1][i]:
                    newstop.append(self.stop[i])
                else:
                    newstop.append(bounds[1][i])
            self.start = tuple(newstart)
            self.stop = tuple(newstop)
        else:
            self.start = incrTuple(bounds[0])
            self.stop = decrTuple(bounds[1])
            self.no_inds = len(self.start)

        # TODO: Remove debug print
        # print "   innerTupleIterator: newbounds: ",self.start,self.stop
        self.it = tupleIterator(self.no_inds,self.start,self.stop)


     
class cornerTupleIterator(object):

    # TODO: Check this fact. 
    # I let the regular cornerTupleIterator adopt the functionality from the
    # NoDup version. I can not se a reason right now that we should allow this
    # one to give duplicates. 
    #
    def __init__(self,no_inds,start,stop):
        self.no_inds = no_inds
        self.start = start
        self.stop = stop

        self.nstart=_n.array(start)
        self.nstop =_n.array(stop)
        zero=getZeroTuple(start)
        ones=getOnesTuple(start)
        self.zeroit = tupleIterator(self.no_inds,zero,ones)

        # if start[i] == stop[i] for some i, set ones[i]=0 for this i
        lones = list(ones)
        for i in xrange(self.no_inds):
            if self.start[i] == self.stop[i]:
                #lones=list(ones)
                lones[i] = 0
        ones=tuple(lones)
        self.zeroit = tupleIterator(self.no_inds,zero,ones)

    def __iter__(self):
        return self

    def reset(self):
        self.zeroit.reset()

    def getBounds(self):
        """Get bounds for this tupleIterator
           Parameters: 
            none
           Returns:
            a tuple with two tuples, start and stop index.
        """
        return (self.start,self.stop)

    def setNewBounds(self,bounds,iOB=False):
        """Set new bounds for the iterator. Restrict to old bounds if iOB=True
           
           Parameters:
             bounds: A tuple or list of tuples setting the extreme min and max
                     bounds for the iterator, just like start and stop in the 
                     constructor. len of start and stop should match, and if 
                     different from the old no_inds, a new number of space dimensions
                     must be set.
             iOB: a True/False flag, short for intersectOldBoundaries. The meaning 
                  is that if this flag is True, we restrict the tuples actually 
                  generated by the iterator to the intersection between the old and
                  new boundaries, such that no tuple generated by the new iterator 
                  is outside the set of tuples generated by the old bounds.
        """
        
        if iOB:
            flag = True
            newstart = []
            newstop = []
            if self.no_inds != len(bounds[0]):
                raise UtilsError, "intersectOldBoundaries requested, but dimensions disagree"
            for i in xrange(len(bounds[0])):
                if bounds[0][i] == self.start[i]:
                    newstart.append(bounds[0][i])
                elif bounds[1][i] == self.stop[i]:
                    newstart.append(self.stop[i])
                else:
                    # we can not reach any of the old corners.
                    flag = False
                if bounds[1][i] == self.stop[i]:
                    newstop.append(bounds[1][i])
                elif bounds[0][i] == self.start[i]:
                    newstop.append(bounds[0][i])
                else:
                    # we can not reach any of the old corners.
                    flag = False
            if flag:
                self.start = newstart
                self.stop = newstop
                self.nstart = _n.array(self.start)
                self.nstop = _n.array(self.stop)
                zero = getZeroTuple(self.start)
                ones = getOnesTuple(self.start)
                self.zeroit = tupleIterator(self.no_inds,zero,ones)
                lones = list(ones)
                for i in xrange(self.no_inds):
                    if self.start[i] == self.stop[i]:
                        lones[i] = 0
                ones = tuple(lones)
                self.zeroit = tupleIterator(self.no_inds,zero,ones)
            else:
                # flag is zero, nothing to iterate over.
                self.zeroit = nullGenerator()
        else:
            self.no_inds = len(bounds[0])
            self.start = bounds[0]
            self.stop = bounds[1]

            self.nstart = _n.array(self.start)
            self.nstop = _n.array(self.stop)
            zero = getZeroTuple(self.start)
            ones = getOnesTuple(self.start)
            self.zeroit = tupleIterator(self.no_inds,zero,ones)

            lones = list(ones)
            for i in xrange(self.no_inds):
                if self.start[i] == self.stop[i]:
                    #lones=list(ones)
                    lones[i] = 0
            ones=tuple(lones)
            self.zeroit = tupleIterator(self.no_inds,zero,ones)

    def next(self):
        # TODO: this should probably not use try/except, sounds like a bad idea in 
        # a next, as this certainly introduce nested try/except...
        # So, why am I doing that? Can yield be used instead?
        #
        try:
            i = self.zeroit.next()
            ni=_n.array(i)
            return tuple((self.nstop*ni) + (self.nstart - (self.nstart*ni)))
        except StopIteration:
            raise StopIteration

#        for i in self.zeroit:
#            ni = _n.array(i)
#            yield tuple((self.nstop*ni) + (self.nstart - (self.nstart*ni)))
#        raise StopIteration

class cornerTupleIteratorNoDuplicates(object):
    # TODO: This should probably be removed. Check!!! 
    # At least, setNewBounds is missing.
    def __init__(self,no_inds,start,stop):
        self.no_inds = no_inds
        self.start = start
        self.stop = stop

        self.nstart=_n.array(start)
        self.nstop =_n.array(stop)
        zero=getZeroTuple(start)
        ones=getOnesTuple(start)
      
        # if start[i] == stop[i] for some i, set ones[i]=0 for this i
        lones = list(ones)
        for i in xrange(self.no_inds):
            if self.start[i] == self.stop[i]:
                #lones=list(ones)
                lones[i] = 0
        ones=tuple(lones)
        self.zeroit = tupleIterator(self.no_inds,zero,ones)

    def __iter__(self):
        return self

    def reset(self):
        self.zeroit.reset()

    def getBounds(self):
        """Get bounds for this tupleIterator
           Parameters: 
            none
           Returns:
            a tuple with two tuples, start and stop index.
        """
        return (self.start,self.stop)


    def next(self):
        try:
            i = self.zeroit.next()
            ni=_n.array(i)
            return tuple((self.nstop*ni) + (self.nstart - (self.nstart*ni)))
        except StopIteration:
            raise StopIteration


class circleIterator(object):
    """Iterator for indicies in a circle.
       Relative to some grid, indicies in a circle/sphere (?) inside some region
       is produced.

       This iterator is based on boundaryTupleIterator, which must be given as input.
       Bounds (region) is hence stored in that iterator.
       There must also be some grid associated with this iterator.
    """
    def __init__(self,iter,grid,center,radius,direction='in'):

        if not grid.nsd == len(center):
            raise UtilsError, "Center of circleIterator must be specified as a coordinate in the grid domain (same number of dimesnsion)"

        self.iter = iter
        self.grid = grid
        self.center = center
        self.radius = radius
        self.direction = direction
        self.position = 0
        self.create()
  
    def __iter__(self):
        return self

    def next(self):
        if self.position < len(self.indicies):
            self.position += 1
            return self.indicies[self.position-1]
        else:
            raise StopIteration
    
    def reset(self):
        self.position = 0

    def getBounds(self):
        return self.iter.getBounds()

    def setNewBounds(self,bounds,iOB=False):
        #print "CircleIt, setNewBounds from ",self.iter.getBounds()," to ",bounds,",iOB = ",iOB
        #print "before: ",self.indicies
        self.iter.setNewBounds(bounds,iOB)
        self.create()
        #print "after: ",self.indicies

    def create(self):
        self.indicies = []
        self.iter.reset()
        for i in self.iter:
            if self.direction == 'in':
                if distance(self.grid.indexToPoint(i),self.center) <= self.radius:
                    self.indicies.append(i)
            elif self.direction == 'out':
                if distance(self.grid.indexToPoint(i),self.center) > self.radius:
                    self.indicies.append(i)
            else:
                raise UtilsError,"Unknown direction (%s), must be in or out" % (self.direction)


def distance(P,C):
    return math.sqrt(reduce(_O.add,[(p-c)**2 for (p,c) in zip(P,C)]))

def getZeroTuple(t):
   return tuple(map(lambda x: 0,t))

def getOnesTuple(t):
   return tuple(map(lambda x: 1,t))

def incrTuple(t):
   return tuple(map(lambda x: x+1,t))

def decrTuple(t):
   return tuple(map(lambda x: x-1,t))

def func_mulScalarFunclist(val,funclist):
   """Create function which evalute a funclist w.r.t argument, and multiply
      with some constant: Given x, func(x) := val * [func1,func2,func3,....](x)"""
   #return lambda args : val*reduce(_O.add,map(lambda x,a=args: apply(x,(a,)),funclist))
   #return lambda args : val*reduce(_O.add,map(lambda x: x(args,),funclist))
   # with arg. unroll
   return lambda *args : val*reduce(_O.add,map(lambda x: x(*args),funclist))

def func_mulFuncFunc(func1,func2):
   """Create a functional multiplier. 

      Return a function object which when called with some arg, evalute both
      functions and multiply the result. 

      Both functions have to accept a tuple as argument"""
   mullist=[]
   mullist.append(func1)
   mullist.append(func2)
   #return lambda args : reduce(_O.mul,map(lambda x,a=args : apply(x,(a,)),mullist))
   #return lambda args : reduce(_O.mul,map(lambda x : x(args,),mullist))
   # with arg. unroll
   return lambda *args : reduce(_O.mul,map(lambda x : x(*args),mullist))

def inner(u,v):
    """Compute innerproduct of u and v.
       It is not computed here, we just check type of operands and
       call a suitable innerproduct method"""

    # TODO: This doesn't handle parallelity. Must be updated for that!
    if isinstance(u,_n.ArrayType):
        # assume both are numarrays:
        if parallelLoaded:
            if pypar.size() > 1:
                print "Warning: using inner product in Utils for numerical arrays"
                print "You are in a parallel context, but this method is not"
                print "updated to handel this. The innerproduct will probably be wrong"
        return _n.dot(u,v)
    else:
        # assume that left operand implements inner
        return u.inner(v)



def factor(num):
    factors = [1, int(num)] 
    for i in range(2,(int)(math.sqrt(num) + 1)): 
        if num%i == 0: 
            factors.append(i) 
            if i != num/i: 
                factors.append(int(num/i)) 
    factors.sort() 
    return factors


def greatestsmaller(l,x):
    return (filter(lambda y: y<=x,l))[-1]

def smallestgreater(l,x):
    return (filter(lambda y: y>=x,l))[0]


def partition2D(P,c,n):
    """Partiion a 2D grid on P processors an ideal way.
       P: total number of processors, integer
       c: communication overlap (both ways), tuple of integers
       n: grid divisions, tuple of integers
    """

    #print "c = ", c
    #print "n = ", n
    #print "P = ", P
    # find candidates 
    pz = math.sqrt((1.*P*c[0]*n[0])/(1.*c[1]*n[1]))

    # factors in P:
    Pf = factor(P)

    candidates = []


    # if there are numbers in Pf smaller than or equal to pz, find 
    # the greatest which are smaller:
    # Else, 1 is always a candidate...?
    if min(Pf) <= pz:
        candidates.append(greatestsmaller(Pf,pz))
    else:
        candidates.append(1)

    if max(Pf) >= pz:
        candidates.append(smallestgreater(Pf,pz))

    evalfunc = lambda x: (c[0]*n[0])/x + (c[1]*x*n[1]/P)

    minimum = evalfunc(candidates[0])
    winner = candidates[0]
    #print "candid is", winner
    #print "met is %d" % (minimum)
    for i in candidates[1:]:
        m = evalfunc(i)
        #print "candid is ",i
        #print "met is %d" % (m)
        if m < minimum:
            minimum = m
            winner = i

    
    return (winner,(int)(P/winner))


def metric3d(c,n,p):
    #print "c, n, p: ",c,n,p
    m = 0.0
    for i in xrange(len(c)):
        m += c[i]*n[i]/p[i]

    return m

def partition3D(P,c,n):
    """Partition a 3D grid on P processors an ideal way.
       P: total number of processors, integer
       c: communication overlap (both ways), tuple of integers
       n: grid divisions, tuple of integers
    """

    # TODO: if we try to run this with P with 1, stuff will break down,
    # for instance will the greatest/smallest functions not work correct.
    # P = 2, 3 is also a problem, as the smallestgreater function does not work.
    #
    # factors in P:
    Pf = factor(P)
    
    # need to find p0, p1 and p2. 
    # find candidates for p1
    #
    
    p1 = ((1.*((c[1]*n[1])**2)*P)/(c[2]*n[2]*c[0]*n[0]))**(1./3)
    p1_c = (greatestsmaller(Pf,p1),smallestgreater(Pf,p1))

    p0_lam = lambda x: ((1.*c[0]*n[0]*P)/(1.*c[2]*n[2]*x))**(1./2)

    p0 = map(p0_lam,p1_c)
    
    candidates = []
    for i in xrange(len(p0)):
        # find divisior (?) in P:
        D = P/p1_c[i]
        # find factors in D
        Df = factor(D)
        # two possible p0's:
        if min(Df) <= p0[i] and max(Df) >= p0[i]:
            p0_c = (greatestsmaller(Df,p0[i]),smallestgreater(Df,p0[i]))
        else:
            #print "No candidate here: P, i, D, Df, p0, p1_c: ",P,i,D,Df,p0[i],p1_c
            continue
            # No candidates here?
#        elif min(Df) < p0[i]:
#            p0_c = (greatestsmaller(Df,p0[i]),greatestsmaller(Df,p0[i]))
#        elif max(Df) > p0[i]:
#            p0_c = (smallestgreater(Df,p0[i]),smallestgreater(Df,p0[i]))
#        print "P, i, D, Df, p0_c: ",P,i,D,Df,p0_c
        # append 2 tuples to the candidates
        candidates.append((p0_c[0],p1_c[i],P/(p0_c[0]*p1_c[i])))
        candidates.append((p0_c[1],p1_c[i],P/(p0_c[1]*p1_c[i])))

    minimum  = metric3d(c,n,candidates[0])
    winner = candidates[0]
    for i in candidates[1:]:
        mm = metric3d(c,n,i)
        if mm < minimum:
            minimum = mm
            winner = i

    #print "And the winner is: ",winner
    return winner


def createPartition(P,c,n):
    """Wrapper function for creating processor-partition in 1, 2 and 3 dimensions
    """

    if isinstance(n,type(1)):
        # 1D, just use all processors as the processor-grid
        return (P,)
    elif len(n) == 1:
        # still 1D, but n given as tuple (as it should...)
        return (P,)
    elif len(n) == 2:
        # 2D
        return partition2D(P,c,n)
    elif len(n) == 3:
        # 3D
        return partition3D(P,c,n)

def distributeNodes1D(n,p,forward=True):
    """Distribute 'n' nodes on 'p' processors. The function return an 
       array with len = p with the number of nodes for each subpart.
       If forward=True, and there is a reminder in n/p, the reminder is distributed 
       on the first processors. If forward=False, the reminder is distributed
       from the end.
       Arguments: 
         n, integer, number of nodes to distribute
         p, integer, number of processors to distribute to
         forward, bool (default True), specify direction for distributing reminder
       Returns:
         distr, a list with the number of nodes to be used on each sub-process
    """

    distr = [ n // p for i in xrange(p) ]

    r = n % p
    dir = 1 # default direction
    if r: # there is a reminder, have to distribute this
        if not forward:
            dir = -1
        for i in range(p)[::dir][:r]: # select r first procs in the right direction
            distr[i] += 1

    return distr

def distributeNodes(n,p):
    """Given a partition strategy p and number of nodes in each direction, n,
       Find the distribution of nodes in each direction
       Arguments:
         n, tuple, the number of nodes in each direction
         p, tuple, the number of procs to be used in each direction
       Returns:
         A list of lists, length of the outer list is same as for n and p, while
         length of the inner list corresponds to the numbers in p.
    """

    # in case 1D, and n and/or p is given as numbers, not tuples, switch them 
    # into tuples:
    if isinstance(n,type(1)):
        n = (n,)
    if isinstance(p,type(1)):
        p = (p,)

    distr = []

    for i in xrange(len(n)):
        forw = True
        if i % 2: # swap direction used for adding reminders 
            forw = False

        distr.append(distributeNodes1D(n[i],p[i],forw))

    return distr

def rankToProc(r,ps):
    """Given a rank number r, and the partition scheme ps, compute the
       position in the processor-grid.
       Arguments:
         r, integer, the rank
         ps, tuple of integers, the partition scheme
       Returns:
         a tuple, the position in each direction.
    """

    # In case we are in a 1D case, position is just the rank:
    # the rank should always be an integer, so make it a tuple on return here, 
    # so this function always return a tuple.
    if isinstance(ps,type(1)):
        return (r,)
    elif len(ps) == 1:
        return (r,)
  
    # template for the result
    s = range(len(ps))
    # initial divisor
    m = reduce(_O.mul,ps[:-1])
    # set the last element
    s[-1] = r // m
    # subtractor, remove "one dimension"
    m = s[-1]*m
    for i in range(len(ps))[-2:0:-1]:
        # find new divisor
        mm = reduce(_O.mul,ps[:i])
        # find next element
        s[i] = (r - m) // mm
        # add subtractor, remove "one more dimension"
        m = m + s[i]*mm
    # set the first element
    s[0] = r % ps[0]

    return tuple(s)

def procToRank(p,ps):
    """Given a position in the processor-grid, p, and a partition scheme ps, 
       compute the rank for that process.
       In principle this method should be the reverse of the method above.
       Arguments: 
         p, a tuple giving the process position
         ps, a partition scheme
       Returns:
         an intenger, the rank of this process.
    """

    # In case we are in a 1D case, rank is just position. The position is given
    # as a tuple, while the rank should be integer, hence we make sure that an 
    # integer is returned
    #
    if isinstance(ps,type(1)) or len(ps) == 1:
        # 1D!
        # make sure that p and ps is same type - use integer:
        # that is, convert tuples to integers
        if isinstance(p, type((1,))):
            p = p[0]
        if isinstance(ps, type((1,))):
            ps = ps[0]

        if p >= 0 and p < ps:
            return p
        else:
            # outside allowed range, return rank of -1.
            return -1
    else:
        # higher order, both p and ps are tuple/lists
        rank = p[0]
        for i in xrange(1,len(ps)):
            m = 1
            for j in xrange(i):
                m *= ps[j]
            rank += p[i]*m
        return rank

def tupleAdd(a,b):
    """Add togehter two tuples of same length"""
    return tuple(_n.array(a) + _n.array(b))

def tupleInnerProd(a,b):
    """do an innerprod of two tuples with same length"""
    return _n.dot(_n.array(a),_n.array(b))

def specToNodes(s):
    """Increase each element in the spec with 1 to get the number of 
       nodes in that direction
    """
    return map(lambda x: x+1, s)

def nodesToSpec(n):
    """Decrease each element in the Nodes list with 1 to get the spec
       number in that direction
    """
    return map(lambda x: x-1, n)


def boundsIntersect(a, b):
    """Check whether two boxes described by bounds a and b intersect
       Parameters: a and b, list or tuple of list or tuple, describing the lower 
                   and upper bounds of the two boxes
    """

    # To have an nonzero intersection, all (axi,ayi) intersect (bxi,byi) must 
    # be non-empty.
    # just assume (at least for now) that all dimensions are correct.

    # as long as flag is non-zero, carry on
    flag = 1
    for i in xrange(len(a[0])):
        if flag:
            if a[0][i] > b[1][i] or b[0][i] > a[1][i]:
                flag = 0
    return flag


def nullGenerator():
    i=0
    while i<0:
        i=i+1
        yield i


# generic plot-function for pyFDM. Should dispatch various stuff (in due time)
def plot(u=None,**kwargs):
    if kwargs.has_key('field'):
        u = kwargs['field']
        u.plot(**kwargs)
    elif u:
        u.plot(**kwargs)
    else:
        raise UtilsError, "can not handle plot request"

